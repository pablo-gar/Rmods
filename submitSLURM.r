#--------------------------------------------------------------------
# DESCRIPTION
#
# A collection of methods that allow a job submission to a SLURM
# cluster from R
#
# It has been tested and optimized to work in the sherlock cluster at Stanford University:
# sherlock.stanford.edu
# 
# Author: Pablo Garcia
#
# Original Date: September, 2016
#
# Requirments:
#   - Rmods/misc.r
# 
# IMPORTANT 
# To load this script use
# source("path/To/Rmods/submitSLURM.r", chdir = T)


#--------------------------------------------------------------------

source("./misc.r")


#--------------------------------------------------------------------
# GLOBAL CONFIG VARIABLES

# Time it waits for resubmmiting a system command (systemSubmit)
TIME_WAIT_RESUBMISSION = 5

# Time it waits for when clusterSubmmit has submmitted the maximum number of Jobs allowed
TIME_WAIT_MAXJOBS = 60

# Default user
SLURM_USER = "paedugar"

# Max number of jobs allowed in cluster
SLURM_MAX_JOBS = 2000
#--------------------------------------------------------------------


#--------------------------------------------------------------------
# METHODS

clusterSubmit <- function (jobName, outDir, commandList, queue = "hbfraser", time = NULL, qos = NULL, nodes = NULL, mem = NULL, deleteScript = FALSE, email = NULL, proc = NULL, totalProc = NULL, maxJobs = SLURM_MAX_JOBS, user = SLURM_USER){
    
    # Submmits a list of system commands as job to a SLURM scheduler.
    # It works in the sherlock cluster at Stanford university, sherlock.stanford.edu
    # 
    # It works by creating a submission SLURM script and then call sbacth from R
    # 
    # jobName - string - Name of job to give to SLURM
    # outDir - string - path to folder where *.out and *.err files will be created.
    # commandList - vector/string - vector containing the system commands to execute
    # queue - string - SLURM queue
    # time - string - time of execution in format "hh:mm:ss"
    # qos  - string - SLURM qos
    # nodes - string - number of nodes that it will use
    # mem - string - memory to be used (e.g. "8G", "8000")
    # deleteScript - TRUE - If TRUE deletes the submission script that is generated by this script and located at outDir
    # email - string - email address to send finalization message
    # proc - string/numeric - number of processors to use
    # maxJobs - numeric - Maximum number of jobs to be running at a give time. This function will go to sleep for 1 min 
    #                       when there are already maxJobs runnings. It will keep trying until there are less than
    #                       maxJobs running.
    #
    # RETURN - string - jobId if submission was completed
    
    # Creating vector with all the info for the batch submission file
    arg <- "#SBATCH "
    args <- "#!/bin/bash\n"
    args <- c(args, paste0(arg , "--job-name=" , jobName))
    args <- c(args, paste0(arg , "--output=" , file.path(outDir, paste0(jobName , ".out"))))
    args <- c(args, paste0(arg , "--error=" , file.path(outDir, paste0(jobName , ".err"))))
    args <- c(args, paste0(arg , "--partition=" , queue))
    if (!is.null(time)) args <- c(args, paste0(arg , "--time=" , as.character(time)))
    if (!is.null(qos)) args <- c(args, paste0(arg , "--qos=" , as.character(qos)))
    if (!is.null(nodes)) args <- c(args, paste0(arg , "--nodes=" , as.character(nodes)))
    if (!is.null(mem)) args <- c(args, paste0(arg , "--mem=" , as.character(mem)))
    if (!is.null(email)){ 
        args <- c(args, paste0(arg , "--mail-type=END"))
        args <- c(args, paste0(arg , "--mail-user=" , as.character(email)))
    }
    if (!is.null(proc)) 
        args <- c(args, paste0(arg , "--cpus-per-task=" , as.character(proc)))
    if (!is.null(totalProc))    
        args <- c(args, paste0(arg , "--ntasks=" , as.character(totalProc)))
    
    if (is.vector(commandList)){
        args <- c(args, commandList)
    }else{
        stop("commandList has to be a character vector")
    }
    
    
    # Writing submmision script for sbatch SLURM
    scriptName = file.path(outDir, paste0(jobName , ".batch"))
    writeLines(args, scriptName)
    
    # Wait if the number of Jobs allowed has been exceeded
    while(getJobNumber(user) >= maxJobs) {
        Sys.sleep(TIME_WAIT_MAXJOBS)
    }
    
    # Executing script
    jobId <- getJobId(systemSubmit(paste0("sbatch " , scriptName), ignore.stdout = F))
    
    # If needed delete script
    if (deleteScript)
        system(paste0("rm " , scriptName))
    
    return(jobId)
    
}

getJobNumber <- function(user = SLURM_USER) {
    
    # Returns the number of jobs of a given user
    
    jobNumber <- systemSubmit(paste0("squeue -u ", user, " | wc -l"), intern = TRUE, ignore.stderr = TRUE, ignore.stdout = FALSE)
    jobNumber <- as.integer(jobNumber) - 1
    return(jobNumber)
    
}

getJobId <- function(x, format = "SLURM") { 
    
    # Takes the stdout of a submission execution (e.g. sbtach script.sh) and 
    # retrieves the jobId number
    #
    # x - string - the stdout string representation of a batch submission
    # format - string - the scheduler used for the submission, currenlty supported:
    #                   -SLURM
    
    if (format == "SLURM") {
        return (gsub(".+?(\\d+)$", "\\1", x))
    } else {
        warning("Imposible to retrieve Job ID, format not recognized")
        return(NULL)
    }
}

systemSubmit <- function(command, n = 12, ignore.stdout = TRUE, ignore.stderr = F, intern = TRUE, ...) {
    
    # Tries executing a command up to n times while the execution returns a
    # non-zero exit status.
    # Useful when trying to automatically submmit a job and the scheduler has problems,
    # then this will try several times if submission fails for any reason
    #
    # command - string - system command to execute
    # n - integer - number of times to try executing command in case it returns a non-zero exit status
    # ignore.stdout - logical - if TRUE it won't return the standard output of execution
    # ignore.stderr - logical - if TRUE it won't return the standard error of execution
    # ... - to be passed to system()
    # 
    # return  - system return object - see ?system
    
    stopifnot(is.character(command), length(command) == 1)
    
    count = 0
    while(count < n) {
        
        commandResult <- suppressWarnings(system(command, intern = intern, ignore.stdout = ignore.stdout, ignore.stderr = ignore.stderr, ...))
        exitStatus <- attr(commandResult, "status")
        
        if(is.null(exitStatus))
            break
        if(exitStatus == 0)
            break
        
        count = count + 1
        cat("\nSomething went wrong with the job submmission, trying again in ", TIME_WAIT_RESUBMISSION, " seconds\n")
        Sys.sleep(TIME_WAIT_RESUBMISSION)
    }
    
    if(count == n)
        stop("\n\nFailed to submmit after ", n, " tries:\n", 
             "   ", command, "\n",
             "   Last exit code: ", exitStatus, "\n")
    
    return(commandResult)
    
}

# END
#--------------------------------------------------------------------
